/**
 * AI Swarm v3.0.0 - Deploy Configuration Service
 * 
 * Loads and resolves deployment configuration from multiple sources:
 * 1. Database (user override) - highest priority
 * 2. File (ai-swarm.deploy.yaml) - project config
 * 3. LLM-generated - auto-detection
 * 4. Default - safe fallback
 */

import { existsSync, readFileSync, writeFileSync } from 'fs';
import { join } from 'path';
import * as yaml from 'js-yaml';
import { logger } from '../logger.js';
import type {
    DeployConfig,
    DeployMode,
    ResolvedDeployConfig,
    DeployConfigSource,
} from '../types.js';

// Config file name (industry standard: project root)
const CONFIG_FILE_NAME = 'ai-swarm.deploy.yaml';

// =============================================================================
// SAFETY RAILS
// =============================================================================

/** Safe deploy command patterns (whitelist) */
const SAFE_DEPLOY_COMMANDS: RegExp[] = [
    /^docker compose (up|restart|build|pull)/,
    /^docker-compose (up|restart|build|pull)/,
    /^git pull/,
    /^git fetch/,
    /^npm run \w+$/,
    /^pnpm (run )?\w+$/,
    /^yarn \w+$/,
    /^make \w+$/,
];

/** Blocked command patterns (blacklist) */
const BLOCKED_PATTERNS: RegExp[] = [
    /rm\s+-rf/i,
    /rm\s+-r\s+\//i,
    /chmod\s+777/,
    />\s*\/etc\//,
    /curl.*\|.*bash/,
    /wget.*\|.*bash/,
    /eval\s*\(/,
    /\$\(.*\)/,  // Command substitution
];

/**
 * Check if a command is safe to execute.
 */
export function isCommandSafe(command: string): { safe: boolean; reason?: string } {
    // Check blacklist first
    for (const pattern of BLOCKED_PATTERNS) {
        if (pattern.test(command)) {
            return { safe: false, reason: `Command matches blocked pattern: ${pattern}` };
        }
    }

    // Check if matches any safe pattern
    const matchesSafe = SAFE_DEPLOY_COMMANDS.some(pattern => pattern.test(command));
    if (!matchesSafe) {
        return { safe: false, reason: 'Command does not match any safe pattern' };
    }

    return { safe: true };
}

// =============================================================================
// DEFAULT CONFIG
// =============================================================================

/**
 * Default deploy configuration (safe fallback).
 */
export function getDefaultDeployConfig(): DeployConfig {
    return {
        version: '1',
        mode: 'git-direct',
        build: {
            base: '.',
            command: '',
            outputDir: 'dist',
        },
        deploy: {
            services: [],
            preCommand: '',
            command: 'docker compose up -d --build',
            postCommand: '',
        },
        verify: {
            browserTest: false,
            healthUrl: '',
        },
    };
}

// =============================================================================
// FILE LOADING
// =============================================================================

/**
 * Load deploy config from ai-swarm.deploy.yaml file.
 */
export async function loadFromFile(projectDir: string): Promise<DeployConfig | null> {
    const configPath = join(projectDir, CONFIG_FILE_NAME);

    if (!existsSync(configPath)) {
        logger.debug({ configPath }, 'No deploy config file found');
        return null;
    }

    try {
        const content = readFileSync(configPath, 'utf-8');
        const parsed = yaml.load(content) as Partial<DeployConfig>;

        // Merge with defaults to ensure all fields exist
        const defaults = getDefaultDeployConfig();
        const config: DeployConfig = {
            version: parsed.version || defaults.version,
            mode: parsed.mode || defaults.mode,
            build: { ...defaults.build, ...parsed.build },
            deploy: { ...defaults.deploy, ...parsed.deploy },
            verify: { ...defaults.verify, ...parsed.verify },
        };

        logger.info({ configPath, mode: config.mode }, 'Loaded deploy config from file');
        return config;
    } catch (error) {
        logger.error({ error, configPath }, 'Failed to parse deploy config file');
        return null;
    }
}

/**
 * Write deploy config to ai-swarm.deploy.yaml file.
 */
export async function writeConfigFile(projectDir: string, config: DeployConfig): Promise<void> {
    const configPath = join(projectDir, CONFIG_FILE_NAME);

    const content = `# ai-swarm.deploy.yaml - Deployment Configuration
# This file was auto-generated by AI Swarm.
# You can customize it or delete to re-trigger auto-detection.

${yaml.dump(config, { indent: 2, lineWidth: 100 })}`;

    writeFileSync(configPath, content, 'utf-8');
    logger.info({ configPath, mode: config.mode }, 'Wrote deploy config file');
}

// =============================================================================
// DATABASE LOADING
// =============================================================================

/**
 * Load deploy config override from database.
 */
export async function loadFromDatabase(projectId: string): Promise<Partial<DeployConfig> | null> {
    try {
        const { projectService } = await import('./ProjectService.js');
        const deployment = await projectService.getProductionDeployment(projectId);

        if (!deployment?.metadata) {
            return null;
        }

        const metadata = deployment.metadata as Record<string, unknown>;

        // Check for deployMode override
        if (!metadata.deployMode) {
            return null;
        }

        const override: Partial<DeployConfig> = {
            mode: metadata.deployMode as DeployMode,
        };

        // Check for deploy command override
        if (metadata.deployCommand) {
            override.deploy = {
                services: [],
                preCommand: '',
                command: metadata.deployCommand as string,
                postCommand: '',
            };
        }

        logger.info({ projectId, mode: override.mode }, 'Loaded deploy config override from database');
        return override;
    } catch (error) {
        logger.warn({ error, projectId }, 'Failed to load deploy config from database');
        return null;
    }
}

// =============================================================================
// RESOLUTION
// =============================================================================

/**
 * Resolve deploy configuration using the priority chain:
 * 1. Database override (user) - highest priority
 * 2. File (ai-swarm.deploy.yaml) - project config
 * 3. Default - safe fallback
 * 
 * Note: LLM generation is handled separately by the analyzeDeployConfig activity.
 */
export async function resolve(
    projectId?: string,
    projectDir?: string
): Promise<ResolvedDeployConfig> {
    let source: DeployConfigSource = 'default';
    let config = getDefaultDeployConfig();

    // Priority 1: Database override
    if (projectId) {
        const dbOverride = await loadFromDatabase(projectId);
        if (dbOverride) {
            config = {
                ...config,
                ...dbOverride,
                build: { ...config.build, ...dbOverride.build },
                deploy: { ...config.deploy, ...dbOverride.deploy },
                verify: { ...config.verify, ...dbOverride.verify },
            };
            source = 'database';
        }
    }

    // Priority 2: File config (only if no database override)
    if (source === 'default' && projectDir) {
        const fileConfig = await loadFromFile(projectDir);
        if (fileConfig) {
            config = fileConfig;
            source = 'file';
        }
    }

    // Validate deploy command safety
    const safetyCheck = isCommandSafe(config.deploy.command);
    if (!safetyCheck.safe) {
        logger.warn({
            command: config.deploy.command,
            reason: safetyCheck.reason
        }, 'Deploy command failed safety check, using default');
        config.deploy.command = getDefaultDeployConfig().deploy.command;
    }

    return {
        ...config,
        source,
        projectId,
    };
}

// =============================================================================
// SERVICE EXPORT
// =============================================================================

export const deployConfigService = {
    resolve,
    loadFromFile,
    loadFromDatabase,
    writeConfigFile,
    getDefaultDeployConfig,
    isCommandSafe,
    CONFIG_FILE_NAME,
};
